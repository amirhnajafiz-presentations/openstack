"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([[111],{3635:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>o});var i=n(4848),r=n(8453);const l={},t="Operating System Security",a={id:"System Security/os",title:"Operating System Security",description:"User level is a set of processs, the kernel does not place requirements",source:"@site/docs/System Security/3_os.md",sourceDirName:"System Security",slug:"/System Security/os",permalink:"/graphhub/docs/System Security/os",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Processor and Virtual Machine Security",permalink:"/graphhub/docs/System Security/vm"},next:{title:"Cryptography",permalink:"/graphhub/docs/System Security/crypto"}},c={},o=[{value:"Processes",id:"processes",level:2},{value:"Virtual memory",id:"virtual-memory",level:3},{value:"Virtual memory allocation",id:"virtual-memory-allocation",level:4},{value:"Process Control Block (PCB)",id:"process-control-block-pcb",level:3},{value:"fork system call",id:"fork-system-call",level:4},{value:"execve system call",id:"execve-system-call",level:4},{value:"exit and wait system calls",id:"exit-and-wait-system-calls",level:4},{value:"Process Scheduling",id:"process-scheduling",level:3},{value:"Process ownership",id:"process-ownership",level:3},{value:"Userids",id:"userids",level:4},{value:"Userid Vs Usernames",id:"userid-vs-usernames",level:3},{value:"File System",id:"file-system",level:2},{value:"Key systemcalls",id:"key-systemcalls",level:3},{value:"Link vs File",id:"link-vs-file",level:2},{value:"Key systemcalls",id:"key-systemcalls-1",level:3},{value:"Interprocess Communication",id:"interprocess-communication",level:2},{value:"I/O redirection",id:"io-redirection",level:3},{value:"Signals",id:"signals",level:2},{value:"Key Signals",id:"key-signals",level:3},{value:"Signal generation",id:"signal-generation",level:3}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"operating-system-security",children:"Operating System Security"})}),"\n",(0,i.jsx)(s.p,{children:"User level is a set of processs, the kernel does not place requirements\non which processes should run."}),"\n",(0,i.jsx)(s.p,{children:"Programs can spawn other programs, orchestrate them to achive higher level goals.\nInterconnect programs using pipes."}),"\n",(0,i.jsx)(s.p,{children:"Everything is a file in operating system. Every device is a file. File permissions provde a universal access control mechanism."}),"\n",(0,i.jsx)(s.p,{children:"System Architecture:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"the users\n--\nshell and commands, compilers and interpreters, system libraries\n---\nsystem-call interface to the kernel\n---\nsignals termianl handling character I/O system terminal drivers\nfile system, swapping block I/O, system disk and tape drivers\nCPU scheduling, page replacement, demand paging, virtual memory\n---\nkernel interface to the hardware\n---\nterminal controllers, terminals\ndevice controllers, disks and tapes\nmemory controllers, physical memory\n"})}),"\n",(0,i.jsx)(s.p,{children:"File System organization:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"/vmunix\n/bin\n/etc\n/dev\n/proc\n/var\n/tmp\n/usr\n/home\n/root\n/boot\n/lib\n/opt\n/mnt\n/media\n/srv\n"})}),"\n",(0,i.jsx)(s.h2,{id:"processes",children:"Processes"}),"\n",(0,i.jsx)(s.p,{children:"Process is a program in execution which has a pid, owner, group, and other attributes.\nProcesses have separate virtual address spaces."}),"\n",(0,i.jsx)(s.p,{children:"This memory isolation provides the basis of security:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"a process cannot access the memory of other processes"}),"\n",(0,i.jsx)(s.li,{children:"access to kernel memory controlled by page permissions"}),"\n",(0,i.jsx)(s.li,{children:"read/write/execute permissions set at the granularity of a page"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"virtual-memory",children:"Virtual memory"}),"\n",(0,i.jsx)(s.p,{children:"Memory organized into pages. Swap space is a disk space for backing up pages that don't fit into physical memory.\nProcessor exception when a page is not in physical memory. OS handles the exception transparently\nto bring this page into memory."}),"\n",(0,i.jsx)(s.h4,{id:"virtual-memory-allocation",children:"Virtual memory allocation"}),"\n",(0,i.jsx)(s.p,{children:"Maybe OS initiated or be requested by a process (using mmap, mprotect)."}),"\n",(0,i.jsx)(s.h3,{id:"process-control-block-pcb",children:"Process Control Block (PCB)"}),"\n",(0,i.jsx)(s.p,{children:"Contains all process state that the OS needs to manage."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"register values"}),"\n",(0,i.jsx)(s.li,{children:"uid, gid, current directory, ..."}),"\n",(0,i.jsx)(s.li,{children:"open file table, file descriptors are indices into this table"}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"fork-system-call",children:"fork system call"}),"\n",(0,i.jsx)(s.p,{children:"When using fork systemcall, child inherits all its parent attributes.\nProcessor time is split accross running processes. Scheduler is responsible for\nstopping one process and giving a turn to the next process."}),"\n",(0,i.jsx)(s.h4,{id:"execve-system-call",children:"execve system call"}),"\n",(0,i.jsx)(s.p,{children:"Used to replace calling process with a new program.\nWhen using this system call, all of the memory is overwritten.\nBut file descriptors are still inherited."}),"\n",(0,i.jsx)(s.h4,{id:"exit-and-wait-system-calls",children:"exit and wait system calls"}),"\n",(0,i.jsx)(s.p,{children:"Processes return a status code when they exit.\nParent receives this status when it waits on a child.\nChild cannot fully exit until parent collects this code, otherwise it will become zombie."}),"\n",(0,i.jsx)(s.h3,{id:"process-scheduling",children:"Process Scheduling"}),"\n",(0,i.jsx)(s.p,{children:"Processor time is split across running processes.\nScheduler is responsible for stopping one process and giving a turn to the\nnext process."}),"\n",(0,i.jsx)(s.h3,{id:"process-ownership",children:"Process ownership"}),"\n",(0,i.jsx)(s.p,{children:"Each process has a owner (uid) and a group (gid) owner.\nA root process can change its uid and gid.\nSetuid permission bit allows uid change on execve.\nBy default, process assumes the uid of the executable file's owner.\nAllos normal users to access features that require privilege (sudo)."}),"\n",(0,i.jsx)(s.h4,{id:"userids",children:"Userids"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Effective userid: all access checks use this id"}),"\n",(0,i.jsx)(s.li,{children:"Real userid: the user that logged in. after executing a setuid executble, real user remains the same but effective user becomes root"}),"\n",(0,i.jsx)(s.li,{children:"Saved userid: under certain conditions, effective uid is saved in saved uid"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"A process is allowed to switch between its real, save, and effective userids."}),"\n",(0,i.jsx)(s.h3,{id:"userid-vs-usernames",children:"Userid Vs Usernames"}),"\n",(0,i.jsx)(s.p,{children:"The file /etc/passwd maps userids to usernames.\nSimilarly, group names are specified in /etc/group.\nNote that /etc/passwd is a public database, however, encrypted passwords are in\n/etc/shadow that can be read only by the root."}),"\n",(0,i.jsx)(s.h2,{id:"file-system",children:"File System"}),"\n",(0,i.jsx)(s.p,{children:"A file is simply a sequence of bytes. Directory is a special file that contains information\nabout the location of files. Path is a sequence of directory names followed by a file name.\nIt made by using Inodes."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"| block |\n|A|B|.|.| => | block A |, | block B |, ...\n"})}),"\n",(0,i.jsx)(s.h3,{id:"key-systemcalls",children:"Key systemcalls"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"open: returns a file descriptor for reading/writing the file"}),"\n",(0,i.jsx)(s.li,{children:"read, write"}),"\n",(0,i.jsx)(s.li,{children:"mmap : map part of a file"}),"\n",(0,i.jsx)(s.li,{children:"lseek : move file pointer to different places"}),"\n",(0,i.jsx)(s.li,{children:"chmod"}),"\n",(0,i.jsx)(s.li,{children:"chown"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"link-vs-file",children:"Link vs File"}),"\n",(0,i.jsx)(s.p,{children:"Hard link is like a file name, it points to the actual file.\nSymlink is a special file that has interpreted as name of another file/dir.\nPath-to-file translation involves dereferencing many links.\nOS limits the number of symlinks travered to prevent infinite loops during lookup."}),"\n",(0,i.jsx)(s.h3,{id:"key-systemcalls-1",children:"Key systemcalls"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"rename"}),"\n",(0,i.jsx)(s.li,{children:"link, unlink"}),"\n",(0,i.jsx)(s.li,{children:"mkdir, rmdir"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"interprocess-communication",children:"Interprocess Communication"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Pipe is a unidirectional communication channel, using its syscall returns\na pair of fd's, which write is in fd[1] and read is in fd[0]. Errors are in fd[2]."}),"\n",(0,i.jsx)(s.li,{children:"socketpair is similar, but allows bidirectional communication."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"io-redirection",children:"I/O redirection"}),"\n",(0,i.jsx)(s.p,{children:"By default, all appplications read from fd[0], write to fd[1], and display\nerrors on fd[2].\nTo redirect input from a file, simply rename the fd to 0."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-sh",children:"dup2(orig_fd, new_fd)\n"})}),"\n",(0,i.jsx)(s.h2,{id:"signals",children:"Signals"}),"\n",(0,i.jsx)(s.p,{children:"Signal is a exception-related control-flow mechanism which is modelled after hardware interrupts.\nA signal can suspend current processing, and gets handled by a signal handler."}),"\n",(0,i.jsx)(s.h3,{id:"key-signals",children:"Key Signals"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"process control: SIGKILL, SIGTERM, SIGINT, SIGQUIT, SIGSTOP, SIGSTP, SIGCONT"}),"\n",(0,i.jsx)(s.li,{children:"illegal memory access: SIGSEGV, SIGBUS"}),"\n",(0,i.jsx)(s.li,{children:"low-level errors: SIGFPE, SIGILL, SIGABRT"}),"\n",(0,i.jsx)(s.li,{children:"child exited: SIGCHLD"}),"\n",(0,i.jsx)(s.li,{children:"timer interrupt: SIGALRM"}),"\n",(0,i.jsx)(s.li,{children:"input/output related condition: SIGPIPE, SIGHUP"}),"\n",(0,i.jsx)(s.li,{children:"bad system call: SIGSYS"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"signal-generation",children:"Signal generation"}),"\n",(0,i.jsx)(s.p,{children:"There two types of signals, sync and async.\nSync signal caused by program execution. While async signal genereted due to external events."}),"\n",(0,i.jsx)(s.p,{children:"Handlers installed using signal or sigaction syscalls. These handlers use a stack that is logically distinct from\nthe program stack."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"SIG_IGN"})," (ignore)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"SIG_DFL"})," (default hanlder"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Signals can be blocked but there is no queue. A signal needs care because\nhandlers execute concurrently with the program."})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>a});var i=n(6540);const r={},l=i.createContext(r);function t(e){const s=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:s},e.children)}}}]);