"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([[105],{1851:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var i=r(4848),a=r(8453);const t={},s="Memory Errors: Exploits and Defenses",o={id:"System Security/memerr-rand",title:"Memory Errors: Exploits and Defenses",description:"Memory layout in stack",source:"@site/docs/System Security/1_memerr-rand.md",sourceDirName:"System Security",slug:"/System Security/memerr-rand",permalink:"/graphhub/docs/System Security/memerr-rand",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Computer Systems Security",permalink:"/graphhub/docs/System Security/intro"},next:{title:"Processor and Virtual Machine Security",permalink:"/graphhub/docs/System Security/vm"}},l={},c=[{value:"Memory layout in stack",id:"memory-layout-in-stack",level:2},{value:"Call stack (Activation Record / Stack Frame)",id:"call-stack-activation-record--stack-frame",level:2},{value:"Stack access",id:"stack-access",level:2},{value:"Caller to Callee",id:"caller-to-callee",level:3},{value:"Callee to Caller",id:"callee-to-caller",level:3},{value:"Stack Smashing",id:"stack-smashing",level:2},{value:"Defense 1: Non-executable data (DEP, NX, W XOR X)",id:"defense-1-non-executable-data-dep-nx-w-xor-x",level:3},{value:"Evasion 1.1: Return to libc",id:"evasion-11-return-to-libc",level:3},{value:"Revasion 1.2: Return-Oriented Programming (ROP)",id:"revasion-12-return-oriented-programming-rop",level:3},{value:"Defense 2: Stack Canary",id:"defense-2-stack-canary",level:3},{value:"Canary Issues",id:"canary-issues",level:4},{value:"ProPolice",id:"propolice",level:3},{value:"Bypassing canaries",id:"bypassing-canaries",level:3},{value:"Other defenses",id:"other-defenses",level:3},{value:"Beyond Stack Smaching",id:"beyond-stack-smaching",level:2},{value:"Overflows in Heap-allocated buffers",id:"overflows-in-heap-allocated-buffers",level:3},{value:"Format-string vulnerabilities",id:"format-string-vulnerabilities",level:3},{value:"Integer overflows",id:"integer-overflows",level:3},{value:"Use-after-free vulnerabilities",id:"use-after-free-vulnerabilities",level:3},{value:"Systematic study of memory errors",id:"systematic-study-of-memory-errors",level:2},{value:"Memory errors",id:"memory-errors",level:3},{value:"Defenses",id:"defenses",level:3},{value:"Prevent memory corruption",id:"prevent-memory-corruption",level:3},{value:"Disrupt exploits",id:"disrupt-exploits",level:3},{value:"Disrupt take-overs (Control-flow hijack)",id:"disrupt-take-overs-control-flow-hijack",level:4},{value:"Automated introduction of diversity",id:"automated-introduction-of-diversity",level:4},{value:"Absolute Address Randomization (AAR/ASLR)",id:"absolute-address-randomization-aaraslr",level:5},{value:"Relative Address Randomization (RAR)",id:"relative-address-randomization-rar",level:5},{value:"Data Space Randomization (DSR)",id:"data-space-randomization-dsr",level:5}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"memory-errors-exploits-and-defenses",children:"Memory Errors: Exploits and Defenses"})}),"\n",(0,i.jsx)(n.h2,{id:"memory-layout-in-stack",children:"Memory layout in stack"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-- high mem\nargv, env\nstack : local variables\n\nheap : dynamic memory allocation\nbss : uninit global data\ndata : init global data\ntext : functions\n-- low mem\n"})}),"\n",(0,i.jsx)(n.h2,{id:"call-stack-activation-record--stack-frame",children:"Call stack (Activation Record / Stack Frame)"}),"\n",(0,i.jsx)(n.p,{children:"Creates for each procedure.\nStructure:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Actual params"}),"\n",(0,i.jsx)(n.li,{children:"Return value"}),"\n",(0,i.jsx)(n.li,{children:"Return address"}),"\n",(0,i.jsx)(n.li,{children:"Saved base pointer (frame pointer)"}),"\n",(0,i.jsx)(n.li,{children:"Local variables"}),"\n",(0,i.jsx)(n.li,{children:"Temp variables"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"stack-access",children:"Stack access"}),"\n",(0,i.jsx)(n.p,{children:"Most items on the stack are accessed relative to Base pointer. A hard-coded offset into binary.\nStack pointer moves on push/pop. However, base pointer only moves on function call/return."}),"\n",(0,i.jsx)(n.h3,{id:"caller-to-callee",children:"Caller to Callee"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Push base pointer onto stack. (save previous function base pointer)"}),"\n",(0,i.jsx)(n.li,{children:"Copy stack pointer to base pointer."}),"\n",(0,i.jsx)(n.li,{children:"reserves stack space for local vars."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"callee-to-caller",children:"Callee to Caller"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Store return value in ",(0,i.jsx)(n.code,{children:"eax"})," or ",(0,i.jsx)(n.code,{children:"rax"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Reset stack to pre-call state."}),"\n",(0,i.jsx)(n.li,{children:"Return control back to the caller."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"stack-smashing",children:"Stack Smashing"}),"\n",(0,i.jsx)(n.p,{children:"Attacker controls the buffer."}),"\n",(0,i.jsx)(n.h3,{id:"defense-1-non-executable-data-dep-nx-w-xor-x",children:"Defense 1: Non-executable data (DEP, NX, W XOR X)"}),"\n",(0,i.jsx)(n.p,{children:"Prevent execution of data that counters direct code injection."}),"\n",(0,i.jsx)(n.h3,{id:"evasion-11-return-to-libc",children:"Evasion 1.1: Return to libc"}),"\n",(0,i.jsx)(n.p,{children:"Use code that already is in process memory.\nlibc is the low-level system library that is part of every program.\nBasically running /bin/bash by using return to libc and controlling the arguments on stack."}),"\n",(0,i.jsx)(n.h3,{id:"revasion-12-return-oriented-programming-rop",children:"Revasion 1.2: Return-Oriented Programming (ROP)"}),"\n",(0,i.jsx)(n.p,{children:"Using stack pointer as the attacker's program counter.\nAs an attacker, don't limit yourself on one or two functions. Instead, use the victim's code as\nyour data. Store your code on stack and use gadgets to execute it.\nPick your code bytes from user code using these gadgets."}),"\n",(0,i.jsx)(n.h3,{id:"defense-2-stack-canary",children:"Defense 2: Stack Canary"}),"\n",(0,i.jsx)(n.p,{children:"Calle generates and stores a canary value on function entry. This value is checked at return.\nIf the canary is dead, then abort the program. Turning control-flow hijack into DoS."}),"\n",(0,i.jsx)(n.h4,{id:"canary-issues",children:"Canary Issues"}),"\n",(0,i.jsx)(n.p,{children:"Fixed values can be detected by attackers.\nRandom canary is better, but the attack can rely on a vulnerability that reveals canary value.\nXOR canary avoids the need for an additional location. However, it's hard to trace and debug."}),"\n",(0,i.jsx)(n.h3,{id:"propolice",children:"ProPolice"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Create a random canary value at process start time"}),"\n",(0,i.jsx)(n.li,{children:"Protect return address and base pointer by locating canary below saved base pointer."}),"\n",(0,i.jsx)(n.li,{children:"Reorder local variables so that simple variables occur after variables subject to overflow."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"-- high mem\nRA\nSaved BP\nCanary\nArray type local vars\nNon-array type local vars\n-- low mem\n"})}),"\n",(0,i.jsx)(n.h3,{id:"bypassing-canaries",children:"Bypassing canaries"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Indirect (aka double pointer) overwrite vulnerability is still an issue."}),"\n",(0,i.jsx)(n.li,{children:"Brute-force attacks: try every possible value for canary until you succeed."}),"\n",(0,i.jsx)(n.li,{children:"Partial overwrite: guess the canary 1-byte at a time"}),"\n",(0,i.jsx)(n.li,{children:"Information leaks: using format-string vulnerability to get memory locations."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"other-defenses",children:"Other defenses"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Shadow Stack: store a copy of return address"}),"\n",(0,i.jsx)(n.li,{children:"Safe Stack: no arrays of any kind on the stack"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"beyond-stack-smaching",children:"Beyond Stack Smaching"}),"\n",(0,i.jsx)(n.h3,{id:"overflows-in-heap-allocated-buffers",children:"Overflows in Heap-allocated buffers"}),"\n",(0,i.jsx)(n.p,{children:"Since there is no return address nearby, attackers should overwrite other code pointers like\nheap metadata or a function pointer."}),"\n",(0,i.jsx)(n.p,{children:"Heap metadata overwrite, provides a primitive to write an attacker chosen value to an attacker\nchosen location."}),"\n",(0,i.jsx)(n.p,{children:"Some systematic solutions are Heap canaries and separate metadata from data."}),"\n",(0,i.jsx)(n.h3,{id:"format-string-vulnerabilities",children:"Format-string vulnerabilities"}),"\n",(0,i.jsxs)(n.p,{children:["Exploits code of the form to read data from attacker into a string. Since printf usual reads memory\n, by passing ",(0,i.jsx)(n.code,{children:"%n"})," you can get memory locations on stack."]}),"\n",(0,i.jsx)(n.h3,{id:"integer-overflows",children:"Integer overflows"}),"\n",(0,i.jsx)(n.p,{children:"Multiple forms:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"variables of different widths"}),"\n",(0,i.jsx)(n.li,{children:"variables of different signs"}),"\n",(0,i.jsx)(n.li,{children:"arithmetic overflows"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"use-after-free-vulnerabilities",children:"Use-after-free vulnerabilities"}),"\n",(0,i.jsx)(n.p,{children:"Attention is to access use-after-free data by dangling pointers."}),"\n",(0,i.jsx)(n.h2,{id:"systematic-study-of-memory-errors",children:"Systematic study of memory errors"}),"\n",(0,i.jsx)(n.h3,{id:"memory-errors",children:"Memory errors"}),"\n",(0,i.jsx)(n.p,{children:"A memory error happens when an object accessed using a pointer expression is\ndifferent from the one intended by the programmer."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Spatial error: out-of-bounds access, access using a corrupted pointer, uninitialized pointer access"}),"\n",(0,i.jsx)(n.li,{children:"Temporal error: access to objects that have been freed"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Most attacks used to be based on spatial errors, but today, temporal errors have\nbecome very important."}),"\n",(0,i.jsx)(n.p,{children:"Typical attacks involve an out-of-bounds write to corrupt a pointer.\nThis means that most attacks rely on multiple memory errors."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Stack Smaching: out-of-bounds write + use of a corrupted pointer as return address"}),"\n",(0,i.jsx)(n.li,{children:"Heap Overflow: out-of-bounds write + corrupted pointer for write and corrupted pointer as target"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"defenses",children:"Defenses"}),"\n",(0,i.jsx)(n.p,{children:"Memory error defenses can divide into two categories:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Prevent memory corruption"}),"\n",(0,i.jsx)(n.li,{children:"Disrupt exploits (guarding solutions)"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"prevent-memory-corruption",children:"Prevent memory corruption"}),"\n",(0,i.jsx)(n.p,{children:"Detect and stop memory corruption before it happens.\nIt is a subclass of spatial errors, where we detect access past the end of valid objects.\nAll spatial errors can be detected by recognizing pointer arithmetic that crosses object boundaries."}),"\n",(0,i.jsx)(n.h3,{id:"disrupt-exploits",children:"Disrupt exploits"}),"\n",(0,i.jsx)(n.p,{children:"Protect attractive targets against common ways to corrupt them."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Disrupt corruption"}),"\n",(0,i.jsx)(n.li,{children:"Disrupt take-overs (Randomization-based defenses)"}),"\n",(0,i.jsx)(n.li,{children:"Disrupt payload execution"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"disrupt-take-overs-control-flow-hijack",children:"Disrupt take-overs (Control-flow hijack)"}),"\n",(0,i.jsx)(n.p,{children:"A key issue for an attack is using their controlled inputs to induce errors with predictable effects.\nTheir approach is to exploit software bugs to overwrite critical data."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Relative address attacks (RA)"}),"\n",(0,i.jsx)(n.li,{children:"Absolute address attacks (AA)"}),"\n",(0,i.jsx)(n.li,{children:"RA + AA attacks"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In order to disrupt them, we use ",(0,i.jsx)(n.strong,{children:"benign diversity"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Preserver functional behaviour"}),"\n",(0,i.jsx)(n.li,{children:"Randomize attack behavior"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"automated-introduction-of-diversity",children:"Automated introduction of diversity"}),"\n",(0,i.jsx)(n.p,{children:"The idea is to use transformations that preserver program semantics.\nThe focus is on programming language semantics."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Address Space Randomization (ASR)"}),"\n",(0,i.jsx)(n.li,{children:"Data Space Randomization (DSR)"}),"\n",(0,i.jsx)(n.li,{children:"Instruction Set Randomization (ISR)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Without using randomization, memory errors corrupt memory in a predictable way.\nThis means the attacker knows the exact data item that is corrupted (RAR defense),\nand the correct value to use for corruption (AAR or DSR defenses)"}),"\n",(0,i.jsx)(n.h5,{id:"absolute-address-randomization-aaraslr",children:"Absolute Address Randomization (AAR/ASLR)"}),"\n",(0,i.jsx)(n.p,{children:"Randomize base address of data and code."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"data: stack, heap, static memory"}),"\n",(0,i.jsx)(n.li,{children:"code: libraries and executable regions"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Limits:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Relative address data-only attacks"}),"\n",(0,i.jsx)(n.li,{children:"Information leakage attacks"}),"\n",(0,i.jsx)(n.li,{children:"Brute-force in space domain using NOP padding or Heap spray"}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"relative-address-randomization-rar",children:"Relative Address Randomization (RAR)"}),"\n",(0,i.jsx)(n.p,{children:"Randomize distance between static objects.\nThis is done in compile time.\nRandomize distance between stack objects."}),"\n",(0,i.jsx)(n.p,{children:"To make ROP (return oriented programming) infeasible:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Permute order of functions"}),"\n",(0,i.jsx)(n.li,{children:"Randomly rearrange instructions within a function"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Benefits of RAR:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Defeats the overwrite step, as well the step that uses the overwritten pointer value"}),"\n",(0,i.jsx)(n.li,{children:"Provides higher entropy"}),"\n",(0,i.jsx)(n.li,{children:"Unlike AAR, a single information leak is insufficient to derandomize everything"}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"data-space-randomization-dsr",children:"Data Space Randomization (DSR)"}),"\n",(0,i.jsx)(n.p,{children:"The basic idea is to randomize data representation.\nWe XOR each data object with a distinct random mask.\nTherefore, effect of data corruption becomse non-deterministic."}),"\n",(0,i.jsx)(n.p,{children:"Unlike AAR, DSR protects all data, not just pointers."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var i=r(6540);const a={},t=i.createContext(a);function s(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);